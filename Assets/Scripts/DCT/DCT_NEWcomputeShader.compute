#pragma kernel DCT_Pass1_Rows // Y 채널 DCT + CbCr 저장
#pragma kernel DCT_Pass2_Cols // Y 채널 DCT + Bitstream 임베딩 (Y 계수)
#pragma kernel IDCT_Pass1_Cols // Y 채널 IDCT
#pragma kernel IDCT_Pass2_Rows // Y 채널 IDCT + CbCr 결합 + RGB 변환

// --- 공통 설정 ---
#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
#define SQRT1_N (1.0f / sqrt(BLOCK_SIZE_FLOAT))     // sqrt(1/8)
#define SQRT2_N (sqrt(2.0f / BLOCK_SIZE_FLOAT)) // sqrt(2/8) = sqrt(1/4) = 0.5

// QIM 설정
float QIM_DELTA; // 양자화 스텝 크기 (C#에서 설정)

// 텍스처 크기
uint Width;
uint Height;

// uv 좌표
uint uIndex;
uint vIndex;

// --- 입출력 텍스처 ---
Texture2D<float4> Source; // 원본 이미지 (float4)
RWTexture2D<float> IntermediateBuffer; // ★★★ CHANGED: 중간 Y 버퍼 (float) ★★★
RWTexture2D<float> DCTOutput; // ★★★ CHANGED: 최종 Y DCT 계수 (float) ★★★
RWTexture2D<float2> ChromaBuffer; // ★★★ ADDED: 원본 CbCr 저장용 (float2) ★★★
RWTexture2D<float4> IDCTOutput; // 최종 복원 이미지 (float4)

// --- Bitstream 관련 입력 (Pass 2에서 사용) ---
StructuredBuffer<uint> Bitstream;
uint BitLength;
uint Embed; // 0: 비활성, 1: 활성

// --- 공유 메모리 ---
groupshared float SharedBlockY[BLOCK_SIZE][BLOCK_SIZE]; // Y 채널용
// CbCr은 Pass1에서 쓰고 Pass4에서 읽으므로 공유 메모리 불필요 (직접 텍스처 사용)

// --- 색 공간 변환 함수 (BT.601 기준) ---
// RGB [0,1] to YCbCr [Y:0..1, CbCr:-0.5..0.5]
float3 RGBToYCbCr(float3 rgb)
{
    float y = 0.299f * rgb.r + 0.587f * rgb.g + 0.114f * rgb.b;
    float cb = -0.169f * rgb.r - 0.331f * rgb.g + 0.500f * rgb.b; // Range -0.5 to 0.5
    float cr = 0.500f * rgb.r - 0.419f * rgb.g - 0.081f * rgb.b; // Range -0.5 to 0.5
    return float3(y, cb, cr);
}

// YCbCr [Y:0..1, CbCr:-0.5..0.5] to RGB [0,1]
float3 YCbCrToRGB(float3 ycbcr)
{
    float r = ycbcr.x + 1.402f * ycbcr.z; // y + 1.402 * Cr
    float g = ycbcr.x - 0.344f * ycbcr.y - 0.714f * ycbcr.z; // y - 0.344 * Cb - 0.714 * Cr
    float b = ycbcr.x + 1.772f * ycbcr.y; // y + 1.772 * Cb
    // Saturate to ensure values are in [0, 1] range after conversion
    return saturate(float3(r, g, b));
}

// --- 1D DCT 함수 (이제 float 입력/출력) ---
void DCT_1D_Single(float inputData[BLOCK_SIZE], out float outputData[BLOCK_SIZE], uint groupThreadID_idx)
{
    float sum = 0.0f;
    float k = (float) groupThreadID_idx;
    float Ck = (k == 0.0f) ? SQRT1_N : SQRT2_N;
    for (uint n = 0; n < BLOCK_SIZE; ++n)
    {
        float cosVal = cos(PI * k * (2.0f * n + 1.0f) / (2.0f * BLOCK_SIZE_FLOAT));
        sum += inputData[n] * cosVal;
    }
    outputData[groupThreadID_idx] = Ck * sum;
}

// --- 1D IDCT 함수 (이제 float 입력/출력) ---
void IDCT_1D_Single(float inputData[BLOCK_SIZE], out float outputData[BLOCK_SIZE], uint groupThreadID_idx)
{
    float sum = 0.0f;
    float n = (float) groupThreadID_idx;
    for (uint k = 0; k < BLOCK_SIZE; ++k)
    {
        float K = (float) k;
        float Ck = (K == 0.0f) ? SQRT1_N : SQRT2_N;
        float cosVal = cos(PI * K * (2.0f * n + 1.0f) / (2.0f * BLOCK_SIZE_FLOAT));
        sum += Ck * inputData[k] * cosVal;
    }
    outputData[groupThreadID_idx] = sum;
}

// ==============================================
// DCT Pass 1: Rows (Y DCT + CbCr 저장)
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass1_Rows(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // u 역할
    uint threadY = groupThreadID.y; // 행 y 역할

    // 1. 블록의 한 행(row) 로드 및 YCbCr 변환
    float3 ycbcr[BLOCK_SIZE]; // Store YCbCr for the row locally first
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        uint loadX = blockX + i;
        uint loadY = blockY + threadY;
        if (loadX < Width && loadY < Height)
        {
            ycbcr[i] = RGBToYCbCr(Source.Load(int3(loadX, loadY, 0)).rgb);
        }
        else
        {
            ycbcr[i] = float3(0.0, 0.0, 0.0); // Pad with zero YCbCr
        }
    }

    // 2. Y 채널에 대해 1D DCT 수행
    float rowInputY[BLOCK_SIZE];
    float rowOutputY[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowInputY[i] = ycbcr[i].x;
    } // Extract Y channel

    DCT_1D_Single(rowInputY, rowOutputY, threadX); // Calculate 1D DCT for Y (threadX is k index)

    // 3. 중간 Y 결과 (1D DCT된) 와 원본 CbCr 저장
    uint writeX = blockX + threadX;
    uint writeY = blockY + threadY;
    if (writeX < Width && writeY < Height)
    {
        IntermediateBuffer[uint2(writeX, writeY)] = rowOutputY[threadX]; // Write 1D DCT Y result
        ChromaBuffer[uint2(writeX, writeY)] = ycbcr[threadX].yz; // Write original CbCr (using threadX to index original pixel pos)
    }
}

// ==============================================
// DCT Pass 2: Columns + Bitstream Embedding (Y 처리)
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass2_Cols(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 열 x 역할
    uint threadY = groupThreadID.y; // v 역할

    // 1. 블록의 한 열(column) Y 데이터를 공유 메모리로 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    if (loadX < Width && loadY < Height)
    {
        SharedBlockY[threadY][threadX] = IntermediateBuffer.Load(int3(loadX, loadY, 0)); // Load Y
    }
    else
    {
        SharedBlockY[threadY][threadX] = 0.0f;
    }

    GroupMemoryBarrierWithGroupSync();

    // 2. 각 스레드는 담당 열(threadX)에 대해 1D DCT 수행 (Y 채널)
    float colInputY[BLOCK_SIZE];
    float colOutputY[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colInputY[i] = SharedBlockY[i][threadX];
    }

    DCT_1D_Single(colInputY, colOutputY, threadY); // Calculate 1D DCT for Y (threadY is k index)
    float finalDctCoeffY = colOutputY[threadY]; // Final Y DCT coefficient C_Y(u,v)

    // --- Bitstream 임베딩 (QIM 방식, Y 채널 계수 사용) ---
    if (Embed == 1)
    {
        uint u = threadX;
        uint v = threadY;
        // 예시: C_Y(4, 4) 계수에만 비트 숨김 (★실제 적용 시 범위 확장 필요★)
        if (u == uIndex && v == vIndex)
        {
            uint blockLinearIndex = groupID.y * (Width / BLOCK_SIZE) + groupID.x;
            if (blockLinearIndex < BitLength)
            {
                uint bit = Bitstream[blockLinearIndex];
                float originalCoeffY = finalDctCoeffY;
                if (bit == 0)
                {
                    float n0 = round(originalCoeffY / QIM_DELTA);
                    finalDctCoeffY = n0 * QIM_DELTA;
                }
                else
                {
                    float n1 = round((originalCoeffY - (QIM_DELTA / 2.0f)) / QIM_DELTA);
                    finalDctCoeffY = n1 * QIM_DELTA + (QIM_DELTA / 2.0f);
                }
            }
        }
    }
    // --- 임베딩 끝 ---

    // 3. 최종 Y DCT 계수를 DCTOutput 텍스처에 쓰기
    uint writeX = blockX + threadX; // u
    uint writeY = blockY + threadY; // v
    if (writeX < Width && writeY < Height)
    {
        DCTOutput[uint2(writeX, writeY)] = finalDctCoeffY;
    }
}


// ==============================================
// IDCT Pass 1: Columns (Y 처리)
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass1_Cols(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // u 역할
    uint threadY = groupThreadID.y; // n 역할 (IDCT 결과 행 인덱스)

    // 1. 블록의 Y DCT 계수 한 열(column)을 공유 메모리로 로드
    uint loadX = blockX + threadX; // u
    uint loadY = blockY + threadY; // v
    if (loadX < Width && loadY < Height)
    {
        SharedBlockY[threadY][threadX] = DCTOutput.Load(int3(loadX, loadY, 0)); // Load Y coeff C_Y(u,v)
    }
    else
    {
        SharedBlockY[threadY][threadX] = 0.0f;
    }

    GroupMemoryBarrierWithGroupSync();

    // 2. 각 스레드는 담당 열(threadX=u)에 대해 1D IDCT 수행 (Y 채널)
    float colInputY[BLOCK_SIZE];
    float colOutputY[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colInputY[i] = SharedBlockY[i][threadX];
    } // Get column C_Y(u, v=i)

    IDCT_1D_Single(colInputY, colOutputY, threadY); // Calculate intermediate Y' (threadY is n index)
    float idctResultY = colOutputY[threadY]; // Intermediate Y'(u, n)

    // 3. 중간 Y' 결과를 IntermediateBuffer에 쓰기
    uint writeX = blockX + threadX; // u
    uint writeY = blockY + threadY; // n
    if (writeX < Width && writeY < Height)
    {
        IntermediateBuffer[uint2(writeX, writeY)] = idctResultY;
    }
}


// ==============================================
// IDCT Pass 2: Rows (Y 처리 + CbCr 결합 + RGB 변환)
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass2_Rows(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 최종 픽셀 x 역할
    uint threadY = groupThreadID.y; // 최종 픽셀 y 역할

    // 1. 블록의 한 행(row) 중간 Y' 데이터를 공유 메모리로 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    if (loadX < Width && loadY < Height)
    {
        SharedBlockY[threadY][threadX] = IntermediateBuffer.Load(int3(loadX, loadY, 0)); // Load intermediate Y'
    }
    else
    {
        SharedBlockY[threadY][threadX] = 0.0f;
    }

    GroupMemoryBarrierWithGroupSync();

    // 2. 각 스레드는 담당 행(threadY)에 대해 1D IDCT 수행 (Y 채널)
    float rowInputY[BLOCK_SIZE];
    float rowOutputY[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowInputY[i] = SharedBlockY[threadY][i];
    } // Get row Y'(u'=i, n=threadY)

    IDCT_1D_Single(rowInputY, rowOutputY, threadX); // Calculate final Y'' (threadX is x index)
    float finalPixelValueY = rowOutputY[threadX]; // Final reconstructed Y'' at (x, y)

    // 3. 원본 CbCr 값 로드 (ChromaBuffer 사용)
    uint writeX = blockX + threadX; // 최종 픽셀 x
    uint writeY = blockY + threadY; // 최종 픽셀 y
    float2 originalCbCr = float2(0.0, 0.0);
    if (writeX < Width && writeY < Height)
    {
        originalCbCr = ChromaBuffer.Load(int3(writeX, writeY, 0)); // Load original CbCr
    }

    // 4. 최종 Y'' 와 원본 CbCr 결합 후 RGB 변환
    float3 finalYCbCr = float3(finalPixelValueY, originalCbCr.x, originalCbCr.y);
    float3 finalRGB = YCbCrToRGB(finalYCbCr);

    // 5. 최종 RGB 픽셀 값을 IDCTOutput 텍스처에 쓰기
    if (writeX < Width && writeY < Height)
    {
        IDCTOutput[uint2(writeX, writeY)] = float4(finalRGB.rgb, 1.0f);
    }
}
