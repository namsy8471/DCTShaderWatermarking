#pragma kernel DCT_Pass1_Rows // 1단계: 행(Row) 기준 1D DCT
#pragma kernel DCT_Pass2_Cols // 2단계: 열(Column) 기준 1D DCT + Bitstream 임베딩
#pragma kernel IDCT_Pass1_Cols // 1단계: 열(Column) 기준 1D IDCT
#pragma kernel IDCT_Pass2_Rows // 2단계: 행(Row) 기준 1D IDCT

// --- 공통 설정 ---
#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
#define SQRT1_N (1.0f / sqrt(BLOCK_SIZE_FLOAT))       // sqrt(1/8)
#define SQRT2_N (sqrt(2.0f / BLOCK_SIZE_FLOAT)) // sqrt(2/8) = sqrt(1/4) = 0.5

// 텍스처 크기 (C#에서 설정)
uint Width;
uint Height;

// --- DCT 입력/출력 ---
Texture2D<float4> Source; // 원본 이미지 (Pass 1 입력)
RWTexture2D<float> IntermediateBuffer; // 1단계 결과 (Pass 1 출력 / Pass 2 입력)
RWTexture2D<float> DCTOutput; // 최종 DCT 계수 (Pass 2 출력 / IDCT Pass 1 입력)

// --- Bitstream 관련 입력 (Pass 2에서 사용) ---
StructuredBuffer<uint> Bitstream;
uint BitLength;
uint Embed; // 0: 비활성, 1: 활성

// --- IDCT 출력 ---
// IntermediateBuffer 재사용 (IDCT Pass 1 출력 / IDCT Pass 2 입력)
RWTexture2D<float4> IDCTOutput; // 최종 복원 이미지 (IDCT Pass 2 출력)


// --- 공유 메모리 ---
groupshared float SharedBlock[BLOCK_SIZE][BLOCK_SIZE];

// --- 1D DCT 함수 ---
// inputData: 길이 BLOCK_SIZE의 1D 데이터 배열
// outputData: 길이 BLOCK_SIZE의 1D DCT 결과 배열
// stride: inputData 읽기 간격 (행 처리 시 1, 열 처리 시 BLOCK_SIZE)
// groupThreadID_idx: 현재 스레드의 처리할 인덱스 (0~7)
void DCT_1D(float inputData[BLOCK_SIZE], out float outputData[BLOCK_SIZE], uint groupThreadID_idx)
{
    float sum = 0.0f;
    // k = groupThreadID_idx (결과 주파수 인덱스)
    float k = (float) groupThreadID_idx;
    float Ck = (k == 0.0f) ? SQRT1_N : SQRT2_N; // 정규화 계수

    for (uint n = 0; n < BLOCK_SIZE; ++n)
    {
        // cos( PI * k * (2n + 1) / (2 * N) )
        float cosVal = cos(PI * k * (2.0f * n + 1.0f) / (2.0f * BLOCK_SIZE_FLOAT));
        sum += inputData[n] * cosVal;
    }
    outputData[groupThreadID_idx] = Ck * sum;
}

// --- 1D IDCT 함수 ---
// inputData: 길이 BLOCK_SIZE의 1D DCT 계수 배열
// outputData: 길이 BLOCK_SIZE의 1D IDCT 복원 결과 배열
// stride: inputData 읽기 간격
// groupThreadID_idx: 현재 스레드의 처리할 인덱스 (0~7)
void IDCT_1D(float inputData[BLOCK_SIZE], out float outputData[BLOCK_SIZE], uint groupThreadID_idx)
{
    float sum = 0.0f;
    // n = groupThreadID_idx (복원할 공간 인덱스)
    float n = (float) groupThreadID_idx;

    for (uint k = 0; k < BLOCK_SIZE; ++k)
    {
        float K = (float) k;
        float Ck = (K == 0.0f) ? SQRT1_N : SQRT2_N; // 정규화 계수
        // cos( PI * k * (2n + 1) / (2 * N) )
        float cosVal = cos(PI * K * (2.0f * n + 1.0f) / (2.0f * BLOCK_SIZE_FLOAT));
        sum += Ck * inputData[k] * cosVal;
    }
    // IDCT 정규화 (표준에 따라서는 전체 합에 sqrt(2/N) 또는 다른 상수 곱 필요 없음)
    // DCT-II -> DCT-III 변환 쌍은 종종 추가 스케일링 없이 사용됨 (결과 범위 확인 필요)
    outputData[groupThreadID_idx] = sum;
}


// ==============================================
// DCT Pass 1: Rows
// 각 스레드가 하나의 DCT 계수 C(u, v) 중 행(row) 변환 부분을 계산
// 스레드 그룹: 8x8 (하나의 블록 처리)
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass1_Rows(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // DCT 계수의 u (주파수) 역할
    uint threadY = groupThreadID.y; // 블록 내 행 인덱스 y 역할

    // 1. 블록의 한 행(row)을 공유 메모리로 로드
    //    각 스레드는 자신의 y좌표(threadY) 행의 x좌표(threadX) 픽셀을 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    if (loadX < Width && loadY < Height)
    {
        float4 sourcePixel = Source.Load(int3(loadX, loadY, 0));
        // 휘도 계산 (또는 R 채널 등 단일 채널 사용)
        SharedBlock[threadY][threadX] = dot(sourcePixel.rgb, float3(0.299f, 0.587f, 0.114f));
    }
    else
    {
        SharedBlock[threadY][threadX] = 0.0f; // 패딩
    }

    GroupMemoryBarrierWithGroupSync(); // 모든 스레드가 로드 완료까지 대기

    // 2. 각 스레드는 자신이 담당하는 행(threadY)에 대해 1D DCT 수행
    //    입력: SharedBlock[threadY] (길이 8 배열)
    //    출력: 임시 저장용 배열 (스레드 로컬) 또는 공유 메모리 재사용(주의!)
    //    여기서는 스레드 로컬 변수 사용 후 공유 메모리에 다시 쓰는 방식 선택
    float rowInput[BLOCK_SIZE];
    float rowOutput[BLOCK_SIZE];

    // 스레드 로컬 배열에 해당 행 데이터 복사
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowInput[i] = SharedBlock[threadY][i];
    }

    // 1D DCT 계산 (현재 스레드는 결과 배열의 threadX 인덱스 담당)
    DCT_1D(rowInput, rowOutput, threadX); // rowOutput[threadX] 에 결과 저장됨

    // 계산된 1D DCT 결과를 다시 공유 메모리에 쓰기 (재사용)
    // 중요: 모든 스레드가 동시에 자기 위치(threadY, threadX)에 쓰므로 충돌 없음
    SharedBlock[threadY][threadX] = rowOutput[threadX];

    GroupMemoryBarrierWithGroupSync(); // 모든 스레드가 1D DCT 및 공유 메모리 쓰기 완료까지 대기

    // 3. 공유 메모리의 중간 결과를 IntermediateBuffer에 쓰기
    //    현재 스레드는 (blockX + threadX, blockY + threadY) 위치 담당
    uint writeX = blockX + threadX;
    uint writeY = blockY + threadY;
    if (writeX < Width && writeY < Height)
    {
        IntermediateBuffer[uint2(writeX, writeY)] = SharedBlock[threadY][threadX];
    }
}


// ==============================================
// DCT Pass 2: Columns + Bitstream Embedding
// 각 스레드가 IntermediateBuffer에서 열(column) 데이터를 읽어 1D DCT 수행 -> 최종 DCT 계수 계산
// 스레드 그룹: 8x8
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass2_Cols(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 블록 내 열 인덱스 x 역할
    uint threadY = groupThreadID.y; // DCT 계수의 v (주파수) 역할

    // 1. 블록의 한 열(column) 데이터를 공유 메모리로 로드
    //    각 스레드는 자신의 x좌표(threadX) 열의 y좌표(threadY) 값을 IntermediateBuffer에서 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    if (loadX < Width && loadY < Height)
    {
        SharedBlock[threadY][threadX] = IntermediateBuffer.Load(int3(loadX, loadY, 0));
    }
    else
    {
        SharedBlock[threadY][threadX] = 0.0f; // 패딩
    }

    GroupMemoryBarrierWithGroupSync(); // 로드 완료 대기

    // 2. 각 스레드는 자신이 담당하는 열(threadX)에 대해 1D DCT 수행
    float colInput[BLOCK_SIZE];
    float colOutput[BLOCK_SIZE];

    // 스레드 로컬 배열에 해당 열 데이터 복사 (전치 효과)
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colInput[i] = SharedBlock[i][threadX]; // 행(i)은 고정, 열(threadX)은 현재 스레드 담당
    }

    // 1D DCT 계산 (현재 스레드는 결과 배열의 threadY 인덱스 담당)
    DCT_1D(colInput, colOutput, threadY); // colOutput[threadY] 에 결과 저장됨

    // 계산된 최종 2D DCT 계수 (C(u,v) = C(threadX, threadY))
    float finalDctCoeff = colOutput[threadY];

    // --- Bitstream 임베딩 (조건부) ---
    if (Embed == 1)
    {
        // 예시: C(4, 4) 계수에만 비트 숨김
        uint u = threadX; // 현재 계산된 DCT 계수의 u 좌표
        uint v = threadY; // 현재 계산된 DCT 계수의 v 좌표

        if (u == 4 && v == 4)
        {
            uint blockLinearIndex = groupID.y * (Width / BLOCK_SIZE) + groupID.x;
            if (blockLinearIndex < BitLength)
            {
                uint bit = Bitstream[blockLinearIndex];
                float scaleFactor = 10000.0f; // 필요시 조정
                uint coeff_int = uint(finalDctCoeff * scaleFactor);
                coeff_int = (coeff_int & 0xFFFFFFFE) | bit; // LSB 변경
                finalDctCoeff = float(coeff_int) / scaleFactor;
            }
        }
    }
    // --- 임베딩 끝 ---

    // 3. 최종 DCT 계수를 DCTOutput 텍스처에 쓰기
    uint writeX = blockX + threadX; // u 좌표
    uint writeY = blockY + threadY; // v 좌표
    if (writeX < Width && writeY < Height)
    {
        DCTOutput[uint2(writeX, writeY)] = finalDctCoeff;
    }
}


// ==============================================
// IDCT Pass 1: Columns
// DCT 계수를 읽어 열(Column) 기준 1D IDCT 수행
// 스레드 그룹: 8x8
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass1_Cols(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 블록 내 열 인덱스 x (u) 역할
    uint threadY = groupThreadID.y; // 블록 내 행 인덱스 y (v) 역할

    // 1. 블록의 DCT 계수 한 열(column)을 공유 메모리로 로드
    //    스레드는 자신의 x좌표(threadX) 열의 y좌표(threadY) DCT 계수 C(u,v) 로드
    uint loadX = blockX + threadX; // u
    uint loadY = blockY + threadY; // v
    if (loadX < Width && loadY < Height)
    {
        // DCTOutput에서 읽음 (이전 단계의 결과)
        SharedBlock[threadY][threadX] = DCTOutput.Load(int3(loadX, loadY, 0));
    }
    else
    {
        SharedBlock[threadY][threadX] = 0.0f;
    }

    GroupMemoryBarrierWithGroupSync(); // 로드 완료 대기

    // 2. 각 스레드는 자신이 담당하는 열(threadX)에 대해 1D IDCT 수행
    float colInput[BLOCK_SIZE];
    float colOutput[BLOCK_SIZE];

    // 스레드 로컬 배열에 해당 열 데이터 복사 (전치 효과)
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colInput[i] = SharedBlock[i][threadX]; // i=v, threadX=u
    }

    // 1D IDCT 계산 (결과 배열의 threadY 인덱스 담당)
    // 입력은 DCT 계수(주파수 영역 k), 출력은 공간 영역 값(n)의 중간 결과
    IDCT_1D(colInput, colOutput, threadY); // colOutput[threadY] 에 결과 저장됨 (n 역할)

    // 계산된 중간 결과를 공유 메모리에 다시 쓰기 (다음 Pass 입력용)
    SharedBlock[threadY][threadX] = colOutput[threadY];

    GroupMemoryBarrierWithGroupSync(); // 쓰기 완료 대기

    // 3. 중간 결과를 IntermediateBuffer에 쓰기 (IDCT Pass 2 입력용)
    //    좌표는 여전히 (u, v) 기반으로 저장됨
    uint writeX = blockX + threadX;
    uint writeY = blockY + threadY;
    if (writeX < Width && writeY < Height)
    {
        IntermediateBuffer[uint2(writeX, writeY)] = SharedBlock[threadY][threadX];
    }
}


// ==============================================
// IDCT Pass 2: Rows
// IntermediateBuffer에서 행(Row) 데이터를 읽어 1D IDCT 수행 -> 최종 픽셀 값 계산
// 스레드 그룹: 8x8
// ==============================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass2_Rows(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockX = groupID.x * BLOCK_SIZE;
    uint blockY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // 최종 픽셀의 블록 내 x 좌표 역할
    uint threadY = groupThreadID.y; // 최종 픽셀의 블록 내 y 좌표 역할

    // 1. 블록의 한 행(row) 데이터를 공유 메모리로 로드
    //    스레드는 자신의 y좌표(threadY) 행의 x좌표(threadX) 값을 IntermediateBuffer에서 로드
    uint loadX = blockX + threadX;
    uint loadY = blockY + threadY;
    if (loadX < Width && loadY < Height)
    {
        SharedBlock[threadY][threadX] = IntermediateBuffer.Load(int3(loadX, loadY, 0));
    }
    else
    {
        SharedBlock[threadY][threadX] = 0.0f;
    }

    GroupMemoryBarrierWithGroupSync(); // 로드 완료 대기

    // 2. 각 스레드는 자신이 담당하는 행(threadY)에 대해 1D IDCT 수행
    float rowInput[BLOCK_SIZE];
    float rowOutput[BLOCK_SIZE];

    // 스레드 로컬 배열에 해당 행 데이터 복사
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        rowInput[i] = SharedBlock[threadY][i]; // i = Pass1 결과의 x좌표(u), threadY = Pass1 결과의 y좌표(n 역할)
    }

    // 1D IDCT 계산 (결과 배열의 threadX 인덱스(최종 x) 담당)
    // 입력은 중간 결과(u, n), 출력은 최종 공간 픽셀 값(x, y)
    IDCT_1D(rowInput, rowOutput, threadX); // rowOutput[threadX] 에 결과 저장됨 (x 역할)

    // 최종 복원된 픽셀 값 (휘도)
    float finalPixelValue = rowOutput[threadX];

    // 3. 최종 픽셀 값을 IDCTOutput 텍스처에 쓰기
    uint writeX = blockX + threadX; // 최종 픽셀 x 좌표
    uint writeY = blockY + threadY; // 최종 픽셀 y 좌표
    if (writeX < Width && writeY < Height)
    {
        // 값 범위 클램핑 (0~1) 및 float4 변환 (그레이스케일)
        finalPixelValue = saturate(finalPixelValue);
        IDCTOutput[uint2(writeX, writeY)] = float4(finalPixelValue, finalPixelValue, finalPixelValue, 1.0f);
    }
}