// HLSL Compute Shader for RGB DCT + Spread Spectrum Watermarking

#pragma kernel DCT_Pass1_Rows_RGB            // Pass 1: RGB 채널 행(Row) DCT
#pragma kernel DCT_Pass2_Cols_EmbedSS_RGB    // Pass 2: RGB 채널 열(Column) DCT + Spread Spectrum 임베딩
#pragma kernel IDCT_Pass1_Cols_RGB           // Pass 3: RGB 채널 열(Column) IDCT
#pragma kernel IDCT_Pass2_Rows_RGB           // Pass 4: RGB 채널 행(Row) IDCT -> 최종 RGB 출력

// --- 공통 설정 및 상수 ---
#define BLOCK_SIZE 8
#define BLOCK_SIZE_FLOAT 8.0f
#define PI 3.14159265359f
#define SQRT1_N (sqrt(1.0f / BLOCK_SIZE_FLOAT)) // sqrt(1/8)
#define SQRT2_N (sqrt(2.0f / BLOCK_SIZE_FLOAT)) // sqrt(2/8) = 0.5

// --- 워터마킹 파라미터 (C#에서 설정) ---
float EmbeddingStrength;
uint CoefficientsToUse;

// --- 전역 변수 (C#에서 설정) ---
uint Width;
uint Height;
uint BitLength;
uint Embed;

// --- 입출력 텍스처 (C#에서 바인딩) ---
Texture2D<float4> Source; // 입력: 원본 RGB 이미지 (Pass 1)
RWTexture2D<float3> IntermediateBufferRGB; // 중간: RGB 각 채널의 행 DCT 결과 또는 열 IDCT 결과 (Pass 1<->2, Pass 3->4)
RWTexture2D<float3> DCTOutputRGB; // 중간: RGB 각 채널의 최종 DCT 계수 (SS 임베딩 포함) (Pass 2->3)
RWTexture2D<float4> FinalOutput; // 출력: 최종 워터마크된 RGB 이미지 (Pass 4)

// --- 입력 버퍼 (C#에서 바인딩) ---
StructuredBuffer<uint> Bitstream; // 입력: 삽입할 비트 데이터 (Pass 2)
StructuredBuffer<float> PatternBuffer; // 입력: 확산 스펙트럼 패턴 (+1/-1) (Pass 2)

// --- 지그재그 스캔 순서 (AC 계수만, 63개) ---
static const uint2 ZigZagIndices[63] =
{ /* ... 이전과 동일 ... */
    uint2(0, 1), uint2(1, 0), uint2(2, 0), uint2(1, 1), uint2(0, 2), uint2(0, 3), uint2(1, 2), uint2(2, 1),
    uint2(3, 0), uint2(4, 0), uint2(3, 1), uint2(2, 2), uint2(1, 3), uint2(0, 4), uint2(0, 5), uint2(1, 4),
    uint2(2, 3), uint2(3, 2), uint2(4, 1), uint2(5, 0), uint2(6, 0), uint2(5, 1), uint2(4, 2), uint2(3, 3),
    uint2(2, 4), uint2(1, 5), uint2(0, 6), uint2(0, 7), uint2(1, 6), uint2(2, 5), uint2(3, 4), uint2(4, 3),
    uint2(5, 2), uint2(6, 1), uint2(7, 0), uint2(7, 1), uint2(6, 2), uint2(5, 3), uint2(4, 4), uint2(3, 5),
    uint2(2, 6), uint2(1, 7), uint2(2, 7), uint2(3, 6), uint2(4, 5), uint2(5, 4), uint2(6, 3), uint2(7, 2),
    uint2(7, 3), uint2(6, 4), uint2(5, 5), uint2(4, 6), uint2(3, 7), uint2(4, 7), uint2(5, 6), uint2(6, 5),
    uint2(7, 4), uint2(7, 5), uint2(6, 6), uint2(5, 7), uint2(6, 7), uint2(7, 6), uint2(7, 7)
};

// --- 1D DCT 함수 (Type-II) ---
// ★★★ 이 함수의 정확성이 여전히 중요! ★★★
void DCT_1D_Single(float inputData[BLOCK_SIZE], out float outputData, uint k_idx)
{
    float k = (float) k_idx;
    float Ck = (k == 0.0f) ? SQRT1_N : SQRT2_N;
    float sum = 0.0f;
    for (uint n = 0; n < BLOCK_SIZE; ++n)
    {
        float n_float = (float) n;
        float angle_term = PI * (2.0f * n_float + 1.0f) * k / (2.0f * BLOCK_SIZE_FLOAT);
        sum += inputData[n] * cos(angle_term);
    }
    outputData = Ck * sum;
}

// --- 테스트용: DCT 계산 대신 입력을 그대로 통과시키는 함수 ---
// 원래 DCT_1D_Single 함수 대신 이것을 사용해서 테스트합니다.
void DCT_1D_Single_PassThroughTest(float inputData[BLOCK_SIZE], out float outputData, uint k_idx)
{
    // inputData 배열에서 k_idx 위치의 값을 그대로 outputData로 전달합니다.
    // 실제 DCT 계산을 하지 않습니다.
    if (k_idx < BLOCK_SIZE) // 안전을 위한 경계 확인
    {
        outputData = inputData[k_idx];
    }
    else
    {
        outputData = 0.0f; // 혹시 모를 경우 대비
    }
}

// --- 1D IDCT 함수 (Type-II) ---
// ★★★ 이 함수의 정확성이 여전히 중요! ★★★
void IDCT_1D_Single(float inputData[BLOCK_SIZE], out float outputData, uint n_idx)
{
    float n = (float) n_idx;
    float sum = 0.0f;
    for (uint k = 0; k < BLOCK_SIZE; ++k)
    {
        float K_float = (float) k;
        float Ck = (K_float == 0.0f) ? SQRT1_N : SQRT2_N;
        float angle_term = PI * (2.0f * n + 1.0f) * K_float / (2.0f * BLOCK_SIZE_FLOAT);
        sum += Ck * inputData[k] * cos(angle_term);
    }
    outputData = sum;
}


// =========================================================================
// Pass 1: RGB 채널 행(Row) DCT
// =========================================================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass1_Rows_RGB(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x; // k 인덱스 / 픽셀 x 인덱스
    uint threadY = groupThreadID.y; // 행 y 인덱스

    // 1. 현재 스레드가 담당하는 행(y=threadY)의 8개 픽셀 로드 (RGB)
    float3 sourcePixelsRGB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        uint loadX = blockOriginX + i;
        uint loadY = blockOriginY + threadY;
        if (loadX < Width && loadY < Height)
        {
            sourcePixelsRGB[i] = Source.Load(int3(loadX, loadY, 0)).rgb;
        }
        else
        {
            sourcePixelsRGB[i] = float3(0.0f, 0.0f, 0.0f);
        }
        // YCbCr 변환 제거됨
    }

    // 2. R, G, B 각 채널에 대해 1D DCT 수행
    float rowInputR[BLOCK_SIZE], rowInputG[BLOCK_SIZE], rowInputB[BLOCK_SIZE];
    for (uint j = 0; j < BLOCK_SIZE; ++j)
    {
        rowInputR[j] = sourcePixelsRGB[j].r;
        rowInputG[j] = sourcePixelsRGB[j].g;
        rowInputB[j] = sourcePixelsRGB[j].b;
    }

    float dctResultR, dctResultG, dctResultB;
    DCT_1D_Single(rowInputR, dctResultR, threadX); // R 채널 DCT
    DCT_1D_Single(rowInputG, dctResultG, threadX); // G 채널 DCT
    DCT_1D_Single(rowInputB, dctResultB, threadX); // B 채널 DCT
    
    //DCT_1D_Single_PassThroughTest(rowInputR, dctResultR, threadX); // 테스트 함수 호출
    //DCT_1D_Single_PassThroughTest(rowInputG, dctResultG, threadX); // 테스트 함수 호출
    //DCT_1D_Single_PassThroughTest(rowInputB, dctResultB, threadX); // 테스트 함수 호출

    // 3. 결과를 float3 형태로 IntermediateBufferRGB에 저장
    uint writeX = blockOriginX + threadX; // k 인덱스
    uint writeY = blockOriginY + threadY; // y 인덱스
    if (writeX < Width && writeY < Height)
    {
        IntermediateBufferRGB[uint2(writeX, writeY)] = float3(dctResultR, dctResultG, dctResultB);
    }
    // CbCr 저장 제거됨
}


// =========================================================================
// Pass 2: RGB 채널 열(Column) DCT + Spread Spectrum 임베딩
// =========================================================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCT_Pass2_Cols_EmbedSS_RGB(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadU = groupThreadID.x; // 열 (x)
    uint threadV = groupThreadID.y; // 행 (y)

    // 1. 열 방향 DCT 수행 (SharedBlock 없이)
    float3 colPixels[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        uint loadX = blockOriginX + threadU;
        uint loadY = blockOriginY + i;
        if (loadX < Width && loadY < Height)
        {
            colPixels[i] = IntermediateBufferRGB.Load(int3(loadX, loadY, 0));
        }
        else
        {
            colPixels[i] = float3(0, 0, 0);
        }
    }

    float colR[BLOCK_SIZE], colG[BLOCK_SIZE], colB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colR[i] = colPixels[i].r;
        colG[i] = colPixels[i].g;
        colB[i] = colPixels[i].b;
    }

    float dctResultColR, dctResultColG, dctResultColB;
    DCT_1D_Single(colR, dctResultColR, threadV);
    DCT_1D_Single(colG, dctResultColG, threadV);
    DCT_1D_Single(colB, dctResultColB, threadV);

    float3 dctResult = float3(dctResultColR, dctResultColG, dctResultColB);

    // 2. Spread Spectrum 임베딩 (옵션)
    if (Embed == 1)
    {
        uint numBlocksX = (Width + BLOCK_SIZE - 1) / BLOCK_SIZE;
        uint blockLinearIndex = groupID.y * numBlocksX + groupID.x;

        if (blockLinearIndex < BitLength)
        {
            uint bit = Bitstream[blockLinearIndex];
            float bit_sign = (bit == 1) ? 1.0f : -1.0f;
            uint pattern_base_idx = blockLinearIndex * CoefficientsToUse;

            if (threadU == 0 && threadV == 0) // 하나의 스레드에서만 임베딩 수행
            {
                for (uint i = 0; i < CoefficientsToUse; ++i)
                {
                    if (i < 63)
                    {
                        uint pattern_idx = pattern_base_idx + i;
                        uint2 embedUV = ZigZagIndices[i];
                        uint u = blockOriginX + embedUV.x;
                        uint v = blockOriginY + embedUV.y;

                        if (u < Width && v < Height)
                        {
                            float pattern_value = PatternBuffer[pattern_idx];
                            float modification = EmbeddingStrength * pattern_value * bit_sign;

                            float3 coeff = DCTOutputRGB[uint2(u, v)];
                            coeff += float3(modification, modification, modification);
                            DCTOutputRGB[uint2(u, v)] = coeff;
                        }
                    }
                }
            }
        }
    }

    // 3. 결과 쓰기
    uint writeX = blockOriginX + threadU;
    uint writeY = blockOriginY + threadV;
    if (writeX < Width && writeY < Height)
    {
        DCTOutputRGB[uint2(writeX, writeY)] = dctResult;
    }
}



// =========================================================================
// Pass 3: RGB 채널 열(Column) IDCT
// =========================================================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass1_Cols_RGB(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadU = groupThreadID.x;
    uint threadV = groupThreadID.y;

    // 1. DCT 계수 읽기 (col 방향)
    float3 colCoeffs[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        uint loadX = blockOriginX + threadU;
        uint loadY = blockOriginY + i;
        if (loadX < Width && loadY < Height)
        {
            colCoeffs[i] = DCTOutputRGB.Load(int3(loadX, loadY, 0));
        }
        else
        {
            colCoeffs[i] = float3(0, 0, 0);
        }
    }

    float colR[BLOCK_SIZE], colG[BLOCK_SIZE], colB[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        colR[i] = colCoeffs[i].r;
        colG[i] = colCoeffs[i].g;
        colB[i] = colCoeffs[i].b;
    }

    float idctR, idctG, idctB;
    IDCT_1D_Single(colR, idctR, threadV);
    IDCT_1D_Single(colG, idctG, threadV);
    IDCT_1D_Single(colB, idctB, threadV);

    // 2. 결과 저장
    uint writeX = blockOriginX + threadU;
    uint writeY = blockOriginY + threadV;
    if (writeX < Width && writeY < Height)
    {
        IntermediateBufferRGB[uint2(writeX, writeY)] = float3(idctR, idctG, idctB);
    }
}


// =========================================================================
// Pass 4: RGB 채널 행(Row) IDCT -> 최종 RGB 출력
// =========================================================================
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCT_Pass2_Rows_RGB(uint3 id : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint blockOriginX = groupID.x * BLOCK_SIZE;
    uint blockOriginY = groupID.y * BLOCK_SIZE;
    uint threadX = groupThreadID.x;
    uint threadY = groupThreadID.y;

    // 1. Intermediate RGB (행 방향)
    float3 rowPixels[BLOCK_SIZE];
    for (uint i = 0; i < BLOCK_SIZE; ++i)
    {
        uint loadX = blockOriginX + i;
        uint loadY = blockOriginY + threadY;
        if (loadX < Width && loadY < Height)
        {
            rowPixels[i] = IntermediateBufferRGB.Load(int3(loadX, loadY, 0));
        }
        else
        {
            rowPixels[i] = float3(0, 0, 0);
        }
    }

    float rowR[BLOCK_SIZE], rowG[BLOCK_SIZE], rowB[BLOCK_SIZE];
    
    for (uint j = 0; j < BLOCK_SIZE; ++j)
    {
        rowR[j] = rowPixels[j].r;
        rowG[j] = rowPixels[j].g;
        rowB[j] = rowPixels[j].b;
    }

    float idctR, idctG, idctB;
    IDCT_1D_Single(rowR, idctR, threadX);
    IDCT_1D_Single(rowG, idctG, threadX);
    IDCT_1D_Single(rowB, idctB, threadX);

    float3 finalPixel = float3(idctR, idctG, idctB);

    // 2. 최종 출력 (saturate 적용)
    uint writeX = blockOriginX + threadX;
    uint writeY = blockOriginY + threadY;
    if (writeX < Width && writeY < Height)
    {
        FinalOutput[uint2(writeX, writeY)] = float4(saturate(finalPixel), 1.0f);
    }
}