#pragma kernel DCTKernel

// 입력 텍스처
Texture2D<float4> Source;
// DCT 계수 출력 (예: RFloat 포맷)
RWTexture2D<float> DCTOutput;

// --- Bitstream 관련 입력 ---
StructuredBuffer<uint> Bitstream; // 숨길 비트 데이터 (0 또는 1)
uint BitLength; // Bitstream의 총 비트 수
uint Embed; // 임베딩 활성화 플래그 (C#에서 설정)
// ------------------------------

// 텍스처 크기
uint Width;
uint Height;

// 상수 정의
#define BLOCK_SIZE 8
#define PI 3.14159265359f

// 스레드 그룹 공유 메모리
groupshared float SourceBlock[BLOCK_SIZE][BLOCK_SIZE];

// DCT 계수 계산 함수 (구현은 이전 답변 참고)
float CalculateDCTCoefficient(uint u, uint v, float blockData[BLOCK_SIZE][BLOCK_SIZE])
{
    float sum = 0.0f;
    for (uint y = 0; y < BLOCK_SIZE; ++y)
    {
        for (uint x = 0; x < BLOCK_SIZE; ++x)
        {
            float pixelValue = blockData[y][x];
            // 성능 최적화를 위해 cos 값은 미리 계산해서 전달하는 것이 좋음
            float cosX = cos((2.0f * x + 1.0f) * u * PI / (2.0f * BLOCK_SIZE));
            float cosY = cos((2.0f * y + 1.0f) * v * PI / (2.0f * BLOCK_SIZE));
            sum += pixelValue * cosX * cosY;
        }
    }
    // 정규화 계수 (단순화 버전)
    float cu = (u == 0) ? (1.0f / sqrt(BLOCK_SIZE)) : (sqrt(2.0f / BLOCK_SIZE));
    float cv = (v == 0) ? (1.0f / sqrt(BLOCK_SIZE)) : (sqrt(2.0f / BLOCK_SIZE));
    return cu * cv * sum * 0.25f;
}


[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void DCTKernel(uint3 id : SV_DispatchThreadID,
               uint3 groupID : SV_GroupID,
               uint3 groupThreadID : SV_GroupThreadID)
{
    uint2 pixelCoord = id.xy;
    uint2 blockStartCoord = groupID.xy * BLOCK_SIZE;
    uint u = groupThreadID.x; // 블록 내 x 좌표 -> 주파수 u
    uint v = groupThreadID.y; // 블록 내 y 좌표 -> 주파수 v

    // 1. 블록 데이터 공유 메모리 로드
    if (pixelCoord.x < Width && pixelCoord.y < Height)
    {
        float4 sourcePixel = Source.Load(int3(pixelCoord, 0));
        // 휘도 계산 또는 다른 채널 사용 가능
        float luminance = dot(sourcePixel.rgb, float3(0.299f, 0.587f, 0.114f));
        SourceBlock[v][u] = luminance;
    }
    else
    {
        SourceBlock[v][u] = 0.0f; // 패딩
    }
    GroupMemoryBarrierWithGroupSync(); // 모든 스레드 대기

    // 2. DCT 계수 C(u, v) 계산
    float dctCoeff = CalculateDCTCoefficient(u, v, SourceBlock);

    // 3. Bitstream 임베딩 (조건부 실행)
    if (Embed == 1)
    {
        // 예시: C(4, 4) 계수에만 각 블록의 비트를 숨김
        if (u == 4 && v == 4)
        {
            // 블록의 1차원 인덱스 계산
            uint blockLinearIndex = groupID.y * (Width / BLOCK_SIZE) + groupID.x;

            // 비트스트림 범위 확인
            if (blockLinearIndex < BitLength)
            {
                uint bit = Bitstream[blockLinearIndex]; // 숨길 비트

                // Scaled Integer LSB 방법으로 임베딩
                float scaleFactor = 10000.0f;
                uint coeff_int = uint(dctCoeff * scaleFactor);
                coeff_int = (coeff_int & 0xFFFFFFFE) | bit;
                dctCoeff = float(coeff_int) / scaleFactor;
            }
        }
    }

    // 4. 결과 쓰기
    uint2 outputCoord = blockStartCoord + uint2(u, v);
    if (outputCoord.x < Width && outputCoord.y < Height)
    {
        DCTOutput[outputCoord] = dctCoeff;
    }
}

// --- IDCT 커널 추가 ---
#pragma kernel IDCTKernel

// 입력: DCT 계수 (DCTKernel의 출력, 예: RFloat)
// RW 대신 Texture2D를 사용해야 할 수도 있으나, 이전 단계에서 RW로 썼다면 RW로 읽는 것도 가능은 함.
// 안전하게 가려면 DCT 결과를 별도 Texture2D로 Blit 후 읽거나, Texture2D<float>로 선언. 여기서는 RW로 시도.
RWTexture2D<float> DCTInput;
// 출력: 복원된 픽셀 이미지 (최종 결과용 포맷, 예: float4)
RWTexture2D<float4> IDCTOutput;

// 입력으로 Width, Height가 이미 선언되어 있음 (재선언 불필요)

// 공유 메모리: 8x8 DCT 계수 블록 저장용
groupshared float CoeffBlock[BLOCK_SIZE][BLOCK_SIZE];

// IDCT 계산 함수
// x, y: 복원할 픽셀의 블록 내 좌표 (0~7)
// coeffBlockData: 8x8 DCT 계수 블록 데이터
float CalculateIDCTPixelValue(uint x, uint y, float coeffBlockData[BLOCK_SIZE][BLOCK_SIZE])
{
    float sum = 0.0f;
    for (uint v = 0; v < BLOCK_SIZE; ++v)
    {
        for (uint u = 0; u < BLOCK_SIZE; ++u)
        {
            float dctCoeff = coeffBlockData[v][u]; // 공유 메모리에서 계수 읽기

            // 정규화 계수 (DCT 때와 동일)
            float Cu = (u == 0) ? (1.0f / sqrt(BLOCK_SIZE)) : (sqrt(2.0f / BLOCK_SIZE));
            float Cv = (v == 0) ? (1.0f / sqrt(BLOCK_SIZE)) : (sqrt(2.0f / BLOCK_SIZE));

            // IDCT 공식 적용 (코사인 값 계산)
            // 성능을 위해 코사인 값 미리 계산 필요
            float cosX = cos((2.0f * x + 1.0f) * u * PI / (2.0f * BLOCK_SIZE));
            float cosY = cos((2.0f * y + 1.0f) * v * PI / (2.0f * BLOCK_SIZE));

            // 스케일링 주의: DCT 계산 시 적용한 스케일링(예: *0.25)을 고려해야 할 수 있음
            // 여기서는 DCT의 단순화된 스케일링(cu*cv*sum*0.25)에 맞춰 역으로 계산
            // 정확한 매칭을 위해 DCT/IDCT 공식을 표준에 맞춰 재검토 필요
            sum += Cu * Cv * dctCoeff * cosX * cosY;
        }
    }
    // DCT 계산 시 *0.25f 를 했다면, IDCT 최종 결과에 *4 를 해야 할 수도 있음.
    // 또는 공식 자체에 스케일링 포함. 여기서는 DCT/IDCT 대칭성 가정하고 추가 스케일링 생략.
    // 결과 값 범위 (예: 0~1)를 위해 clamp 처리 필요할 수 있음
    return sum;
}


// 스레드 그룹 크기는 8x8 (IDCT 블록 크기와 동일)
[numthreads(BLOCK_SIZE, BLOCK_SIZE, 1)]
void IDCTKernel(uint3 id : SV_DispatchThreadID, // 전체 픽셀 좌표 (x,y)
               uint3 groupID : SV_GroupID, // 블록 좌표
               uint3 groupThreadID : SV_GroupThreadID) // 블록 내 픽셀 좌표 (x,y 역할)
{
    uint2 pixelCoord = id.xy; // 복원할 픽셀 좌표

    // 현재 스레드가 속한 블록의 시작 좌표
    uint2 blockStartCoord = groupID.xy * BLOCK_SIZE;

    // 현재 스레드의 블록 내 좌표 (0~7) -> x, y 역할
    uint tx = groupThreadID.x;
    uint ty = groupThreadID.y;

    // 1. 8x8 DCT 계수 블록을 공유 메모리로 로드
    // 각 스레드는 자신의 위치(tx, ty) -> (u, v)에 해당하는 계수 값을 로드
    uint2 coeffCoord = blockStartCoord + uint2(tx, ty); // 계수 텍스처 좌표
    if (coeffCoord.x < Width && coeffCoord.y < Height)
    {
        // DCTInput에서 계수 로드
        CoeffBlock[ty][tx] = DCTInput.Load(int3(coeffCoord, 0)); // ty=v, tx=u
    }
    else
    {
        CoeffBlock[ty][tx] = 0.0f; // 패딩
    }

    // 모든 스레드가 공유 메모리 로드 완료까지 대기
    GroupMemoryBarrierWithGroupSync();

    // 2. IDCT 픽셀 값 계산
    // 각 스레드는 자신의 블록 내 좌표(tx, ty)를 픽셀 좌표(x, y)로 사용하여
    // 하나의 픽셀 값 Pixel(x, y)를 계산합니다.
    uint x = tx;
    uint y = ty;
    float pixelValue = CalculateIDCTPixelValue(x, y, CoeffBlock);

    // 3. 계산된 픽셀 값을 출력 텍스처에 쓰기
    // 결과를 그레이스케일로 출력 가정 (필요 시 RGB 처리)
    // 값 범위 클램핑 (예: 0~1)
    pixelValue = saturate(pixelValue); // saturate(v) = clamp(v, 0.0, 1.0)
    float4 outputColor = float4(pixelValue, pixelValue, pixelValue, 1.0f);

    // 출력 텍스처 좌표는 pixelCoord ( = id.xy) 와 동일
    if (pixelCoord.x < Width && pixelCoord.y < Height)
    {
        IDCTOutput[pixelCoord] = outputColor;
    }
}