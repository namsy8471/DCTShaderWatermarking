#pragma kernel CSMain

RWTexture2D<float4> Result;

uint width;
uint height;
float4 triangleColor; // ðŸŽ¨ ì‚¼ê°í˜• ìƒ‰ìƒì„ ìœ„í•œ ë³€ìˆ˜

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height)
        return;

    // ðŸš€ Compute Shaderì˜ Y ì¢Œí‘œë¥¼ ë°˜ì „
    float2 uv = float2(id.x / (float) width, 1.0 - (id.y / (float) height));

    // âœ… ì‚¼ê°í˜•ì„ ì˜¬ë°”ë¥¸ ìŠ¤í¬ë¦° ì¢Œí‘œë¡œ ë³€í™˜
    float2 v0 = float2(0.5 * width, (1.0 - 0.2) * height); // í™”ë©´ ì¤‘ì•™ ìœ„ìª½
    float2 v1 = float2(0.7 * width, (1.0 - 0.8) * height); // ì˜¤ë¥¸ìª½ ì•„ëž˜
    float2 v2 = float2(0.3 * width, (1.0 - 0.8) * height); // ì™¼ìª½ ì•„ëž˜

    float2 p = float2(id.x, id.y);

    // âœ… ì‚¼ê°í˜• ë‚´ë¶€ íŒë³„ (Barycentric ì¢Œí‘œ)
    float2 edge0 = v1 - v0;
    float2 edge1 = v2 - v1;
    float2 edge2 = v0 - v2;

    float2 p0 = p - v0;
    float2 p1 = p - v1;
    float2 p2 = p - v2;

    float cross0 = edge0.x * p0.y - edge0.y * p0.x;
    float cross1 = edge1.x * p1.y - edge1.y * p1.x;
    float cross2 = edge2.x * p2.y - edge2.y * p2.x;

    if ((cross0 > 0 && cross1 > 0 && cross2 > 0) || (cross0 < 0 && cross1 < 0 && cross2 < 0))
    {
        Result[id.xy] = triangleColor; // ì‚¼ê°í˜• ë‚´ë¶€: ë¹¨ê°„ìƒ‰
    }
    else
    {
        Result[id.xy] = float4(0, 0, 0, 0); // ì‚¼ê°í˜• ì™¸ë¶€: íˆ¬ëª…
    }
}
